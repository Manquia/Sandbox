[Vertex]
struct Snake
{
  [BuiltInInput] var FrameTime : Real;
  
  [BuiltInInput] var LocalToView : Real4x4;
  [BuiltInInput] var LocalToViewNormal : Real3x3;
  [BuiltInInput] var LocalToPerspective : Real4x4;
  
  [StageInput] var LocalPosition : Real3;
  [StageInput] var LocalTangent : Real3;
  [StageInput] var LocalBitangent : Real3;
  [StageInput] var LocalNormal : Real3;
  
  [Input] var PT0 : Real3;
  [Input] var PT1 : Real3;
  [Input] var PT2 : Real3;
  [Input] var PT3 : Real3;


  [StageInput][Output] var Uv : Real2;

  [Output] var ViewPosition : Real3;
  [Output] var ViewNormal : Real3;
  [Output] var ViewTangent : Real3;
  [Output] var ViewBitangent : Real3;
  
  [Output] var PerspectivePosition : Real4;

  // assumes model has a height of exactly 1.0 starting from 0 in the y dimension
  function Main()
  {
    var vertPos = this.LocalPosition;
    var localBiTang = Math.Normalize(this.LocalBitangent);
    
    var upVecMid =    Math.Normalize(this.PT2 - this.PT1);
    var upVecFuture = Math.Normalize((this.PT3 - this.PT2) + upVecMid * 0.000001);
    var upVecPast =   Math.Normalize((this.PT1 - this.PT0) + upVecMid * 0.000001);
    
    
    var mu = vertPos.Y;
    
    var upVec = upVecMid *    (1.0 - Math.Abs(mu - 0.5)) +
                upVecPast *   (1.0 - Math.Min(mu + 0.5, 1.0)) + 
                upVecFuture * (Math.Max(mu - 0.5, 0));
                
                
    upVec = Math.Normalize(upVec);
    
    // Beat in and out! like a heart beat!!!
    var sinFrame = Math.Sin(this.FrameTime) * 0.5 + 1;
    var angle = Math.AngleBetween(Real3(0,1,0), upVec);//Math.ATan2(-upVec.X, -upVec.Z);  
    var newLocalPos = Real3(this.LocalPosition.X, 0.0, this.LocalPosition.Z) * sinFrame;
    
    var rotMat : Real3x3 = Real3x3();
    if(angle  > 0.01)
    {
      var rotationAxis = Math.Normalize(Math.Cross(upVec, localBiTang));
      rotMat = Snake.RotationMatrix(rotationAxis, -angle);
      newLocalPos = Math.Multiply(rotMat, newLocalPos);
    }
    
    // @TODO
    //this.Uv = 
    
    var lerpPos = Math.Lerp(this.PT1, this.PT2, mu);
    var pos = newLocalPos + lerpPos;
    var localToViewNormal = Math.Multiply(this.LocalToViewNormal, rotMat);
    
    this.ViewPosition =  Math.MultiplyPoint(this.LocalToView, pos);
    this.ViewNormal =    Math.Normalize(Math.Multiply(localToViewNormal, this.LocalNormal));
    this.ViewTangent =   Math.Normalize(Math.Multiply(localToViewNormal, this.LocalTangent));
    this.ViewBitangent = Math.Normalize(Math.Multiply(localToViewNormal, this.LocalBitangent));
    
    
    this.PerspectivePosition = Math.Multiply(this.LocalToPerspective, Real4(pos, 1.0));
  }
  
  function CatmulRomPos(mu : Real) : Real3
  {
    
    return Real3();
  }
  
  function CatmulRomRotation(mu : Real) : Quaternion
  {
    
    return Quaternion();
  }
  
  
  [Static]
  function RotationMatrix(u : Real3, t : Real) : Real3x3
  {
    var m = Real3x3();
    var sin = Math.Sin(t);
    var cos = Math.Cos(t);
    var cos_1 = 1 - cos;
    
    m.M00 = cos + u.X * u.X * cos_1;
    m.M11 = cos + u.Y * u.Y * cos_1;
    m.M22 = cos + u.Z * u.Z * cos_1;
    
    m.M01 = u.X * u.Y * cos_1 - u.Z * sin;
    m.M02 = u.X * u.Z * cos_1 + u.Y * sin;
    
    m.M10 = u.Y * u.X * cos_1 + u.Z * sin;
    m.M12 = u.Y * u.Z * cos_1 - u.X * sin;
    
    m.M20 = u.Z * u.X * cos_1 - u.Y * sin;
    m.M21 = u.Z * u.Y * cos_1 - u.X * sin;
    
    return m;
  }
}
